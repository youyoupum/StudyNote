# 常用知识总结

## 1.数据库知识



#### 1.1事务的相关理解



 数据库事务的四大特性通常被称为ACID特性，包括原子性、一致性、隔离性和持久性

这些特性是数据库系统设计的核心原则，确保数据的可靠性和一致性。



###### 原子性(**Atomicity**)

- **定义**：事务中的所有操作要么全部成功，要么全部失败回滚。

- 示例：银行转账操作，如果转账过程中任何一步失败，整个转账操作将回滚，确保账户余额正确

  

###### **一致性**(Consistency)

- **定义**：事务执行前后，数据库从一个一致性状态变到另一个一致性状态。

- 示例：在转账操作中，无论转账多少次，两个账户的余额之和保持不变

  

###### 隔离性(**Isolation**)

- **定义**：并发执行的事务之间应该互相隔离，一个事务的执行不应该被其他事务干扰。

- 示例：银行柜台处理不同客户的存取款请求，每个客户都认为自己是独占柜台的，不会受到其他客户操作的影响

  

###### 持久性(Durability)

- **定义**：一旦事务提交，其所做的修改将永久保存在系统中，即使系统发生故障也不会丢失。
- **示例**：银行在你完成存款后，即使电力故障，你的存款记录也会安全地保存在账户上





#### 1.2**范式的相关理解**（**三范式**）：



范式(Normal Form)：三范式是数据库设计中的一种规范，它可以帮助我们创建出结构清晰、冗余少、易于维护的数据库。

###### 第一范式（1NF）

- **定义**：确保每个表中的每个字段都是原子的，不可再分的。
- **要求**：每个字段只能包含一个值，不能有重复或多值字段。
- **示例**：
  - **不规范**：一个用户信息表，其中电话号码字段包含了多个号码。
  - 规范：将每个电话号码单独列出，每个用户只有一个电话号码。

###### 第二范式（2NF）

- **定义**：在满足第一范式的基础上，每个非主键字段完全依赖于整个主键，而不是部分依赖于主键的一部分。

- **要求**：表必须满足第一范式。

- **示例**：

  - **不规范**：一个订单表，其中商品名称和单价依赖于商品ID，而不是整个复合主键（订单ID和商品ID）。

  - 规范：将商品信息拆分成一个独立的商品表。

    

###### 第三范式（3NF）

- **定义**：在满足第二范式的基础上，表中的每一个非主键字段都不传递依赖于主键。
- **要求**：表必须满足第二范式。
- **示例**：
  - **不规范**：一个员工信息表，其中部门名称依赖于部门ID，而部门ID依赖于员工ID，即部门名称传递依赖于主键员工ID。
  - 规范：将部门信息拆分成一个独立的部门表。

作用：三范式是可以帮助我们减少数据冗余和提高数据一致性的。



## 数据结构知识

## 算法知识

##### 3.1数组引用与创建的区别

例：如果直接使用int[] renum = nums这样子的方式创建数组，对于renum中数组进行修改时会同时修改到nums，而如果想要创建一个和nums同样大小的空数组，可以以 int[] renum = new int[nums.length];这样子的方式进行创建，或者直接进行数组的复制

```java
int[] originalArray = {1, 2, 3, 4, 5};
 int[] copiedArray = Arrays.copyOf(originalArray,originalArray.length);
```

## Spring框架相关知识



##### 4.1 IOC和AOP的作用和区别

IoC（Inversion of Control，控制反转）和AOP（Aspect Oriented Programming，面向切面编程）是Spring框架中两个核心概念，它们在软件设计中起到了至关重要的作用。下面将详细介绍它们的作用和区别：

IoC**的作用**

- **解耦**：IoC通过将对象的创建和管理权交给容器，减少了对象之间的直接依赖，从而降低了系统的耦合度。

- 简化开发

  ：开发者不再需要手动创建和管理对象，而是通过容器来获取所需的对象，这使得代码更加简洁，易于维护。

  

AOP**的作用**

- **横切关注点的模块化**：AOP允许将那些影响多个类的公共行为（如日志记录、事务管理、安全控制等）封装到可重用的模块中，这些模块被称为“切面”。

- 提高代码复用性和可维护性

  ：通过AOP，可以将这些横切关注点从核心业务逻辑中分离出来，减少重复代码，提高代码的可维护性和可扩展性。

  

### IoC和AOP的区别

- **目的**：

  - **IoC**：主要目的是实现控制反转，通过容器管理对象的生命周期和依赖关系，从而降低耦合度。

  - **AOP**

    ：主要目的是通过切面编程，将横切关注点从业务逻辑中分离出来，提高代码的模块化和可维护性。

    

- **实现方式**：

  - **IoC**：通常通过依赖注入（DI）来实现，Spring框架提供了多种注入方式，如构造器注入、设值注入等。

  - AOP

    ：基于代理模式实现，Spring AOP支持JDK动态代理和CGLIB动态代理，根据目标类是否有接口来选择合适的代理方式。

- **关注点**：

  - **IoC**：关注对象的创建和依赖关系的管理。
  - **AOP**：关注业务逻辑的横向切分，通过切面实现功能的统一维护。

## Nginx的相关 知识

## 力扣题目

### 数据库题目

##### 550.游戏玩法分析 IV

Table: `Activity`

```
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
（player_id，event_date）是此表的主键（具有唯一值的列的组合）。
这张表显示了某些游戏的玩家的活动情况。
每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0）。
```

 

编写解决方案，报告在首次登录的第二天再次登录的玩家的 **比率**，**四舍五入到小数点后两位**。换句话说，你需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。

结果格式如下所示：

 

**示例 1：**

```
输入：
Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-03-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+
输出：
+-----------+
| fraction  |
+-----------+
| 0.33      |
+-----------+
解释：
只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33
```

```sql
-- 创建一个名为first_login的临时表，其中包含每个玩家的首次登录日期
WITH first_login AS (
    SELECT player_id, MIN(event_date) AS first_date
    FROM Activity
    GROUP BY player_id
),

-- 创建一个名为second_login的临时表，其中包含在首次登录的第二天再次登录的玩家
second_login AS (
    SELECT a.player_id
    FROM Activity a
    JOIN first_login fl ON a.player_id = fl.player_id
    WHERE a.event_date = DATE_ADD(fl.first_date, INTERVAL 1 DAY)
)

-- 计算在首次登录的第二天再次登录的玩家的数量，并除以总玩家数量，得到所需的比例
SELECT ROUND(COUNT(DISTINCT sl.player_id) / COUNT(DISTINCT fl.player_id), 2) AS fraction
FROM first_login fl
LEFT JOIN second_login sl ON fl.player_id = sl.player_id;
```



### 算法题目

##### 1365.有多少小于当前数字的数字（简）

给你一个数组 `nums`，对于其中每个元素 `nums[i]`，请你统计数组中比它小的所有数字的数目。

换而言之，对于每个 `nums[i]` 你必须计算出有效的 `j` 的数量，其中 `j` 满足 `j != i` **且** `nums[j] < nums[i]` 。

以数组形式返回答案。

 

**示例 1：**

```
输入：nums = [8,1,2,2,3]
输出：[4,0,1,1,3]
解释： 
对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
对于 nums[1]=1 不存在比它小的数字。
对于 nums[2]=2 存在一个比它小的数字：（1）。 
对于 nums[3]=2 存在一个比它小的数字：（1）。 
对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。
```

**示例 2：**

```
输入：nums = [6,5,4,8]
输出：[2,1,0,3]
```

**示例 3：**

```
输入：nums = [7,7,7,7]
输出：[0,0,0,0]
```

 

**提示：**

- `2 <= nums.length <= 500`
- `0 <= nums[i] <= 100`



题解：

```java
class Solution {

  public int[] smallerNumbersThanCurrent(int[] nums) {

​    int[] renum = new int[nums.length];

​    for (int i = 0; i < nums.length; i++) {

​      int num = 0;

​      for (int j = 0; j < nums.length; j++) {

​        if (nums[i] > nums[j]) {

​          num++;

​        }

​      }

​      renum[i] = num;

​    }

​    return renum;

  }

}
```

